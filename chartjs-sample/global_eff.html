<!DOCTYPE html>
<html>
<head>
    <title>Hwaseung Vina Global EFF Chart</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.2/Chart.js"></script>
    <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
    <style>
        body {
            font-family: Helvetica Neue, Arial, sans-serif;
            text-align: center;
        }

        .wrapper {
            margin: 0 auto;
        }
    </style>
</head>
<body>
<div class="wrapper">
    <canvas id="myChart" width="70%" height="50%"></canvas>
</div>
<script>
    /*
     * Add bottom margin to legends
     */
    // --------------------START--------------------
    Chart.NewLegend = Chart.Legend.extend({
        afterFit: function() {
            this.height = this.height + 10; // Bottom Margin: 10
        },
    });

    function createNewLegendAndAttach(chartInstance, legendOpts) {
        var legend = new Chart.NewLegend({
            ctx: chartInstance.chart.ctx,
            options: legendOpts,
            chart: chartInstance
        });

        if (chartInstance.legend) {
            Chart.layoutService.removeBox(chartInstance, chartInstance.legend);
            delete chartInstance.newLegend;
        }

        chartInstance.newLegend = legend;
        Chart.layoutService.addBox(chartInstance, legend);
    }

    // Register the legend plugin
    Chart.plugins.register({
        beforeInit: function(chartInstance) {
            var legendOpts = chartInstance.options.legend;

            if (legendOpts) {
                createNewLegendAndAttach(chartInstance, legendOpts);
            }
        },
        beforeUpdate: function(chartInstance) {
            var legendOpts = chartInstance.options.legend;

            if (legendOpts) {
                legendOpts = Chart.helpers.configMerge(Chart.defaults.global.legend, legendOpts);

                if (chartInstance.newLegend) {
                    chartInstance.newLegend.options = legendOpts;
                } else {
                    createNewLegendAndAttach(chartInstance, legendOpts);
                }
            } else {
                Chart.layoutService.removeBox(chartInstance, chartInstance.newLegend);
                delete chartInstance.newLegend;
            }
        },
        afterEvent: function(chartInstance, e) {
            var legend = chartInstance.newLegend;
            if (legend) {
                legend.handleEvent(e);
            }
        }
    });
    // --------------------END--------------------

    updateChart();

    setInterval(function () {
        updateChart();
    }, 60000);

    function updateChart() {
        $(document).ready(function () {
            var obj = new Object();
            obj.SiteID = '6257c91aeca6b8efd08a3cc8bd027c59';
            obj.ObjectName = ['global_eff_data'];
            $.ajax({
                type: 'POST',
                url: 'http://smart.hsvina.com/proxy/Metric/Get',
                data: '{"SiteID": "6257c91aeca6b8efd08a3cc8bd027c59", "ObjectName": [ "global_eff_data" ]}',
                success: function (data) {
                    var chartData = data.Result.global_eff_data.value.metric_1;

                    // Our labels along the x-axis
                    var dayLabels = ['-7D', '-6D', '-5D', '-4D', '-3D', '-2D', '-1D', 'TODAY'];

                    // For drawing the lines
                    var China = [
                        chartData[2][0], chartData[2][1], chartData[2][2], chartData[2][3],
                        chartData[2][4], chartData[2][5], chartData[2][6], chartData[2][7]
                    ];
                    var Vietnam = [
                        chartData[1][0], chartData[1][1], chartData[1][2], chartData[1][3],
                        chartData[1][4], chartData[1][5], chartData[1][6], chartData[1][7]
                    ];
                    var Indonesia = [
                        chartData[0][0], chartData[0][1], chartData[0][2], chartData[0][3],
                        chartData[0][4], chartData[0][5], chartData[0][6], chartData[0][7]
                    ];

                    var minMaxTickYAxesConfig = computeMinMaxTickOnYAxes(false, China, Vietnam, Indonesia);

                    var stepSize = computeStepSize(minMaxTickYAxesConfig.max);

                    buildNewLineChart(dayLabels, China, Vietnam, Indonesia, minMaxTickYAxesConfig, stepSize);
                },
                contentType: "application/json",
                dataType: 'json'
            });
        });
    }

    function buildNewLineChart(dayLabels, China, Vietnam, Indonesia, minMaxTickYAxesConfig, stepSize) {
        var ctx = document.getElementById('myChart');
        var myChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: dayLabels,
                datasets: [
                    {
                        data: China,
                        label: 'China',
                        pointRadius: 0.5,
                        pointStyle: 'rect',
                        borderColor: '#807fff',
                        backgroundColor: '#807fff',
                        fill: false,
                        tension: 0,
                    },
                    {
                        data: Vietnam,
                        label: 'Vietnam',
                        pointRadius: 0.5,
                        pointStyle: 'rect',
                        borderColor: '#f9f6f7',
                        backgroundColor: '#f9f6f7',
                        fill: false,
                        tension: 0,
                    },
                    {
                        data: Indonesia,
                        label: 'Indonesia',
                        pointRadius: 0.5,
                        pointStyle: 'rect',
                        borderColor: '#54cc8e',
                        backgroundColor: '#54cc8e',
                        fill: false,
                        tension: 0,
                    },
                ],
            },
            options: {
                responsive: true,
                legend: {
                    labels: {
                        usePointStyle: true,
                        fontColor: '#777c80',
                    },
                },
                scales: {
                    xAxes: [{
                        ticks: {
                            minRotation: 0,
                            maxRotation: 90,
                            autoSkip: false,
                            fontColor: '#fff',
                            padding: 10,
                        },
                        gridLines: {
                            display: false,
                        },
                    }],
                    yAxes: [{
                        gridLines: {
                            color: '#454749',
                            drawBorder: false,
                        },
                        ticks: {
                            min: minMaxTickYAxesConfig.min,
                            max: minMaxTickYAxesConfig.max,
                            stepSize: stepSize,
                            fontColor: '#fff',
                            padding: 10,
                            callback: function (value, index, values) {
                                return value + '%';
                            },
                        },
                    }],
                },
            },
        });
    }

    // Round up to 0.5 if num < 0.5; Round up to 1.0 if num >= 0.5
    // Example: MAX_VALUE_IN_GRAPH -> MAX_TICK_ON_Y_AXES:
    // 1 -> 5; 3 -> 5; 5 -> 10; 49 -> 50; 50 -> 100;
    // 100 -> 150; 115 -> 150; 140 -> 150; 149 -> 150; 150 -> 200; 170 -> 200;
    // 230 -> 250; 249 -> 250; 250 -> 300; 265 -> 300;
    function computeMinMaxTickOnYAxes(isComputeMinTick, ...arrays) {
        var min = Number.MAX_SAFE_INTEGER, max = 0;
        arrays.map(array => array.map(value => {
            if (value < min) {
                min = value;
            }
            if (value > max) {
                max = value;
            }
        }));

        var numOfDigits = 1;
        if (max % 1 === 0) {
            numOfDigits = max.toString().length;
        } else {
            numOfDigits = Math.round(max).toString().length;
        }

        var factor = 1;
        switch (numOfDigits) {
            case 1:
                factor = 10;
                break;
            case 2:
                factor = 100;
                break;
            default:
                for (var i = 1; i < numOfDigits; ++i) {
                    factor *= 10;
                }
                break;
        }

        var decimalMax = max / factor;
        var temp = Math.floor(decimalMax);
        var fractionalPartOfDecimalMax = decimalMax - temp;

        var maxTickOnYAxes = 0;
        if (fractionalPartOfDecimalMax < 0.5) {
            maxTickOnYAxes = (Math.ceil(decimalMax * 2) / 2) * factor;
        } else {
            maxTickOnYAxes = Math.round(decimalMax) * factor;
        }

        if (isComputeMinTick) {
            return {
                min: min,
                max: maxTickOnYAxes,
            };
        }
        return {
            min: 0,
            max: maxTickOnYAxes,
        };
    }

    function computeStepSize(maxTickOnYAxes) {
        return maxTickOnYAxes % 5 === 0 ? maxTickOnYAxes / 5 : maxTickOnYAxes / 10;
    }
</script>
</body>
</html>
